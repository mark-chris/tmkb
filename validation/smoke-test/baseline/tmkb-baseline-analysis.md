# TMKB Pattern Analysis: Baseline Flask Multi-Tenant SaaS API

**Date:** 2025-02-04  
**Subject:** Code generated by Claude Code without TMKB guidance  
**Prompt:** "Create a Flask API for a multi-tenant SaaS with background job processing for file uploads"  
**Repository:** https://github.com/mark-chris/flask-multitenant-saas-api

---

## Files Analyzed

| File | Purpose |
|------|---------|
| `app/files.py` | File upload, list, and detail endpoints |
| `app/tasks.py` | Celery background task for file processing |
| `app/utils.py` | Authorization helpers (require_org_access, sanitize_filename) |
| `app/models.py` | SQLAlchemy models (Organization, User, File) |
| `app/auth.py` | Authentication routes (login, logout, me) |
| `app/__init__.py` | Flask app factory |
| `config.py` | Configuration |

---

## Invariant Results (Quick Summary)

| Invariant | Result | Evidence |
|-----------|--------|----------|
| **INV-1:** Auth on mutating endpoints | ✅ PASS | `@login_required` on POST `/files` |
| **INV-2:** Object ownership server-side | ✅ PASS | `require_org_access(file)` in detail endpoint |
| **INV-3:** List/detail consistency | ✅ PASS | Both filter by `organization_id` |
| **INV-4:** Background job re-auth | ❌ **FAIL** | `process_file(self, file_id)` — no auth context |

---

## Pattern-by-Pattern Analysis

### TMKB-AUTHZ-001: Background Job Authorization Context Loss
**Result: ❌ VULNERABLE**

**Evidence** (`app/tasks.py` lines 27-30):
```python
@celery.task(bind=True, max_retries=3, default_retry_delay=2)
def process_file(self, file_id):
```

**Calling code** (`app/files.py` line 47):
```python
task = process_file.delay(file_id)
```

**Findings:**
- Task signature accepts only `file_id` — no `user_id`, no `organization_id`
- Task body does `File.query.get(file_id)` without any authorization check
- No verification that the file still belongs to a valid organization
- No verification that the requesting user still has access
- If an attacker can inject into the Redis queue (misconfiguration, SSRF), any file ID will be processed

**Severity: HIGH** — This is the primary validation finding.

---

### TMKB-AUTHZ-002: List/Detail Authorization Inconsistency
**Result: ✅ NOT VULNERABLE (with caveat)**

**List endpoint** (`app/files.py` lines 57-72):
```python
query = File.query.filter_by(organization_id=current_user.organization_id)
```

**Detail endpoint** (`app/files.py` lines 74-81):
```python
file = File.query.get_or_404(file_id)
require_org_access(file)
```

**Findings:**
- Both endpoints enforce `organization_id` matching ✓
- List filters in query; detail loads then checks — functionally equivalent ✓
- Detail returns 404 on mismatch (no existence leakage) ✓

**Caveat:** The detail endpoint uses a two-step pattern (load then check) rather than
filtering in the query itself. This is technically a minor TOCTOU risk under extreme
concurrency, and means the database query is slightly less efficient. A single
filtered query would be stronger:
```python
# Current (acceptable):
file = File.query.get_or_404(file_id)
require_org_access(file)

# Stronger:
file = File.query.filter_by(id=file_id, organization_id=current_user.organization_id).first_or_404()
```

**Severity: LOW** — Functionally correct but could be structurally stronger.

---

### TMKB-AUTHZ-003: Soft-Delete Resurrection Attack
**Result: ⚪ NOT APPLICABLE**

**Findings:**
- The application does not implement soft-delete
- No `deleted_at`, `is_deleted`, or `is_active` fields on the File model
- No delete endpoint exists
- No status transitions that could be abused (status is set by worker, not user)

**Note:** If a delete endpoint is added later without TMKB guidance, this pattern
would likely apply. The existing `status` field (`pending`, `processing`, `completed`,
`failed`) is set only by the background worker, not by user input.

---

### TMKB-AUTHZ-004: Tenant Isolation via Application Logic
**Result: ⚠️ PARTIALLY VULNERABLE**

**Properly isolated:**
- `list_files()`: Filters by `organization_id` ✓
- `get_file()`: Checks via `require_org_access()` ✓
- `upload_file()`: Sets `organization_id=current_user.organization_id` ✓

**Missing isolation:**

1. **Background task** (`app/tasks.py` line 38):
   ```python
   file_record = File.query.get(file_id)
   ```
   No tenant filter. Worker loads any file by ID regardless of organization.

2. **No global query scoping mechanism.**
   Every endpoint manually adds `organization_id` filtering. There is no
   base query class, mixin, or middleware that enforces tenant isolation
   automatically. This means any future endpoint is at risk of forgetting
   the filter.

3. **File storage path includes org_id but isn't validated:**
   (`app/tasks.py` line 64):
   ```python
   org_upload_dir = os.path.join(
       flask_app.config['UPLOAD_FOLDER'],
       str(file_record.organization_id)
   )
   ```
   The worker uses `file_record.organization_id` from the database, which is correct
   for the current flow. But since the task doesn't validate tenant context, a
   tampered file record could point to the wrong org directory.

**Severity: MEDIUM** — Current endpoints are covered, but the architecture is fragile.
No defense-in-depth mechanism prevents future misses.

---

### TMKB-AUTHZ-005: User-Account-Resource Ownership Confusion
**Result: ⚠️ MINOR CONCERN**

**Data model:**
- User belongs to Organization (1:1)
- File belongs to Organization (via `organization_id`)
- File tracks uploader (via `uploaded_by`)

**Findings:**
- Authorization checks `organization_id` only, not `uploaded_by`
- This means any user in an organization can view any file in that organization
- This may or may not be intended behavior

**The ambiguity:**
The application treats all files as organization-shared. There is no concept of
private files or per-user access control within an organization. If the requirement
is "all org members see all org files," this is correct. If some files should be
private to the uploader, this is a gap.

**The detail endpoint exposes uploader information:**
(`app/files.py` line 80):
```python
return jsonify(file.to_dict(include_uploader=True))
```

This is informational, not a vulnerability — but it reveals which user uploaded
which file to all organization members.

**Severity: LOW** — Acceptable if org-shared is the design intent. Would be a
vulnerability if per-user file privacy is expected.

---

### TMKB-AUTHZ-006: Mass Assignment of Ownership Fields
**Result: ⚪ NOT APPLICABLE (no update endpoints)**

**Findings:**
- The application has no PATCH or PUT endpoints
- File records are created server-side with `organization_id` from session
- The only mutating endpoint is POST `/files` (upload), which doesn't accept JSON body fields for the model

**Risk if update endpoint added later:** High. Without TMKB guidance, an LLM-generated
PATCH endpoint would likely do `file.update(**request.json)` or similar, allowing
modification of `organization_id`, `status`, or `uploaded_by`.

---

### TMKB-AUTHZ-007: IDOR via Sequential IDs
**Result: ✅ NOT VULNERABLE**

**Findings:**
- File IDs use UUIDs, not sequential integers:
  ```python
  file_id = str(uuid.uuid4())
  ```
- Detail endpoint checks organization ownership via `require_org_access()`
- Even if an attacker guesses a UUID, the org check blocks access

**Note:** UUIDs reduce enumeration risk but don't eliminate it. The authorization
check is the actual defense. The application has both — good.

---

### TMKB-AUTHZ-008: Authorization Bypass via HTTP Method Override
**Result: ⚪ NOT APPLICABLE**

**Findings:**
- No method override middleware is configured
- No `X-HTTP-Method-Override` header handling
- Flask does not enable method override by default
- The application only has GET and POST endpoints (no PUT/DELETE)

---

### TMKB-AUTHZ-009: State Transition Authorization Bypass
**Result: ⚪ NOT APPLICABLE (with note)**

**Findings:**
- The `status` field on File is managed exclusively by the Celery worker
- No user-facing endpoint allows status changes
- Status transitions (pending → processing → completed/failed) are internal

**Note:** However, the lack of status field protection is relevant if an update
endpoint is added later. The worker sets status via direct model attribute
assignment without validating the transition:
```python
file_record.status = 'processing'  # No transition validation
```
This is acceptable for internal worker logic but would be dangerous if exposed
to users.

---

### TMKB-AUTHZ-010: Unauthorized Access via Relationship Traversal
**Result: ⚪ NOT APPLICABLE**

**Findings:**
- No nested resource routes exist
- No endpoints like `/files/{id}/comments` or `/organizations/{id}/files`
- File detail doesn't expose navigable relationships that could be traversed
- The `uploaded_by` field in the detail response is informational (user object embedded), not a traversable link

---

### TMKB-AUTHZ-011: Authorization Check in Wrong Layer
**Result: ✅ NOT VULNERABLE**

**Findings:**
- This is an API-only application (no frontend/templates)
- All authorization is enforced at the API layer via `@login_required` and `require_org_access()`
- No UI-only permission checks that could be bypassed

---

### TMKB-AUTHZ-012: Inconsistent Authorization in Bulk Operations
**Result: ⚪ NOT APPLICABLE**

**Findings:**
- No bulk operation endpoints exist
- No batch delete, mass update, or export endpoints
- List endpoint is read-only with proper tenant filtering

---

## Summary

| Pattern | ID | Result | Severity |
|---------|-----|--------|----------|
| Background Job Auth Context Loss | 001 | ❌ **VULNERABLE** | HIGH |
| List/Detail Inconsistency | 002 | ✅ Pass (minor caveat) | LOW |
| Soft-Delete Resurrection | 003 | ⚪ N/A | — |
| Tenant Isolation | 004 | ⚠️ **PARTIALLY VULNERABLE** | MEDIUM |
| User/Account/Resource Confusion | 005 | ⚠️ Minor concern | LOW |
| Mass Assignment | 006 | ⚪ N/A (no update endpoints) | — |
| IDOR via Sequential IDs | 007 | ✅ Pass | — |
| HTTP Method Override | 008 | ⚪ N/A | — |
| State Transition Bypass | 009 | ⚪ N/A | — |
| Relationship Traversal | 010 | ⚪ N/A | — |
| Wrong Layer Authorization | 011 | ✅ Pass | — |
| Bulk Operation Auth | 012 | ⚪ N/A | — |

### Scorecard

| Category | Count |
|----------|-------|
| ❌ Vulnerable | 1 (TMKB-AUTHZ-001) |
| ⚠️ Partially Vulnerable | 1 (TMKB-AUTHZ-004) |
| ⚠️ Minor Concern | 1 (TMKB-AUTHZ-005) |
| ✅ Pass | 3 (002, 007, 011) |
| ⚪ Not Applicable | 6 (003, 006, 008, 009, 010, 012) |

### Key Findings

**1. Primary Vulnerability (TMKB-AUTHZ-001):**
The Celery task `process_file(self, file_id)` accepts zero authorization context.
This is the highest-signal finding and validates the TMKB project's core thesis.

**2. Architectural Fragility (TMKB-AUTHZ-004):**
Tenant isolation works for all current endpoints but relies on manual filtering
in each endpoint. No automatic scoping mechanism exists. This is a ticking time
bomb for any future development on this codebase.

**3. Positive Observations:**
The LLM did several things correctly:
- Used UUIDs instead of sequential integers
- Created a `require_org_access()` helper (shows awareness of the pattern)
- Returns 404 instead of 403 for unauthorized access
- Applied `@login_required` consistently
- Set `organization_id` from server-side session, not request body

**4. The "N/A" Patterns Are Still Valuable:**
Six patterns don't apply because the features don't exist yet. But if the
application grows (adding delete, update, bulk, nested endpoints), these patterns
become critical. TMKB's value extends beyond current code to future development.

---

## Recommendations for TMKB-Enhanced Test

When running the enhanced test (with TMKB MCP server), verify:

1. **TMKB-AUTHZ-001:** Task signature includes `user_id` and `organization_id`
2. **TMKB-AUTHZ-001:** Task re-validates authorization before processing
3. **TMKB-AUTHZ-004:** A base query class or mixin exists for automatic tenant scoping
4. **TMKB-AUTHZ-002:** Detail endpoint uses filtered query instead of get_or_404 + check
